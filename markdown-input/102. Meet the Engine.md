# 102. Meet the Engine
Learning goal: Understand the various components of the QIX Engine

<div class="graph"></div>

## Structure of the Associative Model
In the previous chapter, we talked about what the Associative Model is and demonstrated some of the advantages of using it. In this chapter, we will dive into the terminology and mechanics of the Engine. First, let’s set define some baseline terms.
</br>
</br>

The **QIX Engine** itself is the tool that can run an Associative Model. On it’s own, it contains no data or application logic. 
</br>
</br>

A **model** is a file that contains an Associative Model. In Qlik’s API documentation models are referred to as _documents_ or _apps_, but for our purposes the term _model_ makes a bit more sense. It will hold all of the actual data and associations. It also could contain data about our application structure and logic, like storing off definitions for charts or calculations. Models can be saved to disk in the file format <code>.qvf</code>, which is readable by the **QIX Engine**.
</br>
</br>

On it’s own, the model does nothing other than store data. The QIX Engine is responsible for leveraging the model. For example, you might use the QIX Engine to create a new model or open a model. The QIX Engine would be used to load data into the model, to filter the state of the model, or to run some calculations. 
</br>
</br>

To leverage the QIX Engine, you establish a **session** with it. A session connects you to the Engine. Within a session, you can only open and work with 1 model at a time. You can however open multiple sessions with the Engine if needed.
</br>
</br>

In order to leverage the Engine to work with models, we will use API calls to perform various functions with the Engine and our models. These calls are organized into classes.

<div class="graph"></div>

## Classes and their Methods
The QIX Engine is made up of various objects that we can interact with in order to leverage the Associative Model. These objects are organized into classes, with various methods for each class that we can invoke via API calls to the Engine.  Let’s review the classes at a high level before going deeper. 

They are:
* Global – represents the Engine itself and methods specific to it, like getting the Engine’s version or creating a new model
* App – represents models that are created or opened with the Engine
* Field – represents a field within a model
* GenericBookmark – represents a bookmark within a model
* GenericDimension – represents a dimension within a model
* GenericObject – represents an object within a model
* GenericMeasure – represents a measure within a model
* GenericVariable – represents a variable within a model
</br>
</br>

You can see a hierarchical relationship between these classes based on those descriptions. This relationship can be simply stated as follows:

_The Global class can create, open, or delete models. Models contain fields. Models can create, contain, use, and delete bookmarks, dimensions, objects, measures, and variables._
</br>
</br>

We’re familiar with the concept of fields from the previous chapter. Bookmarks, dimensions, objects, measures, and variables are new concepts to us however. Of that list, one of them is absolutely critical to our use of the Associative Model: the Generic Object. The rest are important for Qlik products like Qlik Sense, but they are not necessary for leveraging the QIX Engine directly. For a full breakdown of classes and their methods, check the [Engine API reference](http://help.qlik.com/en-US/sense-developer/June2017/Subsystems/EngineAPI/Content/Classes/classes.htm).
</br>
</br>

Let’s learn more about our 4 key classes: Global, App, Field, and Generic Object.
</br>
</br>
</br>

### The Global Class
Once we have established a session to a QIX Engine (a topic that will be covered later), we will have access to an instance of the Global class. This class has functionality that operates at the Engine level, including functions for getting the Engine version or working with models. Typically we will leverage the Global class for creating, opening, or deleting models. Key methods to be aware of are:

* CreateApp – Creates a new model that is saved to disk
* CreateSessionApp – Creates a new model that is not persisted and can’t be saved to disk. It is only available in the current session
* DeleteApp – Deletes a model from disk
* OpenDoc – Opens a model from disk
</br>
</br>

There are other methods on the Global class that tend to be more useful as part of Qlik products; when working with the Engine directly, we mostly use Global to operate on models as described above.
</br>
</br>
</br>

### The App Class
Once we have opened a model in our session, we will be able to access an instance of the App class that represents the model. The App class has methods that allow us to work with the model. It has many methods; lets highlight a few key ones based on several types of usage.
</br>
</br>

#### State Methods
As we learned in the previous chapter, models have a current state based on selections that are applied in the model. We can modify the model’s state with a few methods:

* ClearAll – Clears all active selections in the model
* Back – Reverts the model to the previous state, if there are any; For example, if I was using my model from chapter 101 and selected **T-Shirt** and then **Camera**, I could use the Back method to remove the last selections (**Camera**) that was added. I could use it again to go back once more and remove the selection before that as well
* Forward – Moves the model to the next state, if there are any
</br>
</br>

#### Search Methods
We can search for data across fields and objects in the model using search methods on the App class:

* SearchResults – Takes search terms and returns lists of fields and generic objects that match the search terms
* SearchSuggestions – Returns suggested search terms based on the inputted search terms and what is in the model
</br>
</br>

#### Field and Object Handling Methods
Once we have the model open, we can interact with fields and objects that serve as interfaces for the actual data in our model. 

* GetField – Takes in a field name and returns an instance of the field
* CreateObject – Takes a definition for a generic object and creates it
* CreateSessionObject - takes a definition for a generic object and creates it; this object will not be persisted in the model outside of the session however
* GetObject – Takes in an ID for an already existing Generic Object and returns an instance of the object
* DeleteObject – Takes in an ID for an existing Generic Object and deletes it from the model
</br>
</br>

#### Calculation Methods
As you will see later, Generic Objects will be our main method for interacting with data in the model. However, you can also perform one-off calculations of data in the model with the App class:
* Evaluate – Takes in a Qlik formula, referred to as an _expression_, evaluates the expression, and returns the value as a string
</br>
</br>
</br>

### The Field Class
In the previous chapter, we showed how data loaded into our model was grouped into fields. For example, we created a field for all of our Fruit values and another field for all of our Color values. When working with a model, we can use the Field class to interact directly with any fields we have loaded. These interactions can include getting some metadata about the field, adjusting behavior of a field, or changing selections in a field:

* GetCardinal – Retrieves the number of distinct values in a field
* Lock – Locks the selected values in a field, disabling methods elsewhere in the model, such as an App class <code>Clear</code> call from modifying the locked fields selections
* Unlock – unlocks a locked field
* Clear – Remove all of the selections in a field
* Select – Selects field values matching a search string
</br>
</br>

Note that the Field class is an interface for interacting with the field itself, but not the _data_ in the field. You cannot use the Field class to get a list of the field values, for example. Fields just exist as a means to get properties of a field or change its state. For getting actual data out of our model, we will use Generic Objects, covered next.
</br>
</br>
</br>

### The Generic Object Class
We’ve mentioned the term Generic Object several times, but we have never discussed what they actually are. Generic Objects are structures for storing and interacting with data in a model. They are our primary mechanism for working with the Engine to calculate dynamic data sets. For example, the calculated table we produced in the previous chapter was created using a Generic Object. In applications built on the QIX Engine, it is common to see Generic Objects used to power charts and filters. 
</br>
</br>

The Generic Object is considered “generic” because it is a flexible structure that can be leveraged to represent any time of entity. For example, in the Qlik Sense product, users can drag and drop charts onto _sheets_, which are like pages. Generic Objects are used to represent charts and sheets in this system, albeit with different structures.
</br>
</br>

Many of the methods used to work with Generic Objects are specific to how a Generic Object is defined and what it is used for. In the next section, we will deep dive on how Generic Objects are used and cover some of the key methods there.

<div class="graph"></div>

## Working with Generic Objects
The Generic Object is our interface for using data in our model. A Generic Object has two components that we rely on for this interaction: a set of properties that define what data will be exposed in the object, and a layout which represents the data from the definition, as evaluated by the model.

<div id="generic-object" class="graph"></div>

### Properties
The properties of a Generic Object are akin to a definition. They define static and dynamic values for the object. They are written as JSON and saved as part of the model. They always have a <code>qInfo/qType</code> property.  Let’s ignore the <code>qType</code> property for now and focus on the static and dynamic properties.

Here is pseudo-code for an example Generic Object:
</br>
</br>

In this example, we’ve labeled some prompters as “static” and some properties as “dynamic”. What’s the difference? Well, keep in mind that we are working with Qlik’s Associative Model. The power of this model is the ability to calculate dynamic data on the fly. A dynamic property is any property that leverages the Engine to calculate a value. In the example above, our static properties do not need the QIX Engine in order to produce a value. They already are values! 

<div id="static-dyn-prop-diagram" class="graph">![](../../imgs/qix-engine.png)</div>

For example, staticProp1 is equal to the number 42. Nothing to calculate there. On the other hand, our dynamic properties are not values. They are formulas for calculating values. If we look at dynamicProp2, we cannot derive the value of that formula. We need the QIX Engine to do that for us, based on the data in our model and the current state of selections.
</br>
</br>

<div class="graph"></div>

The Engine has various dynamic property types that can be defined as part of a Generic Object. We will touch on a couple of them when we build an example dashboard, but if you want to learn more in the meantime, check out the [API reference for Generic Object properties.](http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/EngineAPI/Content/GenericObject/PropertyLevel/properties-that-can-be-set.htm)
</br>
</br>

This brings us to the other side of the Generic Object coin – layouts.

<div id="static-dyn-prop-interactive" class="graph">![](../../imgs/qix-engine.png)</div>

### Layouts
A layout is the result of running a Generic Object properties definition through the QIX Engine. In this process, all static properties are carried over and all dynamic properties are calculated based on the data in the model. Unlike properties, layouts are not saved anywhere. They are calculated on the fly so that we have the most up to date data when we retrieve a layout.
</br>
</br>

In short, properties provide a definition for the data in our Generic Object. Layouts provide the results of evaluating those definitions with our Qlik data. Try playing with this relationship in the diagram to the right!

<div class="graph"></div>

### Generic Object Methods
The Generic Object class has methods that allow us to work with its properties and layout. When we create a Generic Object with our App class, we can pass in the properties at that time. However, we can get and update the properties in a few different ways directly with the Generic Object class via methods like:

* GetProperties – returns the properties of the object
* SetProperties – sets the properties of the object
* ApplyPatches – updates specific pieces of the existing properties
</br>
</br>

We can evaluate our properties through the QIX Engine to get a layout using:

* GetLayout – calculates and returns a layout
</br>
</br>

Later when we work with Generic Objects and dynamic properties, we’ll use methods on the Generic Object that correspond with those dynamic properties. For example, one time of dynamic property is the <code>ListObject</code>, which is useful for representing data from a field in a filter-like format. <code>ListObject</code> are often used to produce filter components, so the Generic Object has specific methods for interacting with this dynamic property, like:

* SelectListObjectValues – Applies selections in the field of the list object based on an input
* SelectListObjectPossible – Applies selections to all possible field values in a field of the list object
</br>
</br>

### Other Class Properties and Layouts
While Generic Objects are the most flexible structure in the model, our other classes have properties as well. Some even have their own layouts. However, their dynamic properties options are much more limited. For example, the App class has properties and a layout that can be retrieved. A model’s layout will include dynamic properties specific to the model, like the last time it was modified.

<div class="graph"></div>

## Fin
#### Recap
* The Engine can create, open, and modify models.
* Models are saved to disk in the file format <code>.qvf</code>. The API documentation refers to models as “apps” or “documents”.
* In order to work with a model, we establish a session with a QIX Engine.
* In a session, we can leverage several classes and their methods to interact with the Engine and models.
* The key classes are Global, App, Field, and GenericObject.
* Generic Objects are our main interface for using model data. They have properties which define them, like metadata. The Engine can evaluate these properties to produce a layout, which is the actual data from the model.

#### Resources
* [Classes ‒ Qlik Sense](http://help.qlik.com/en-US/sense-developer/June2017/Subsystems/EngineAPI/Content/Classes/classes.htm)
* [Properties that can be set ‒ Qlik Sense](http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/EngineAPI/Content/GenericObject/PropertyLevel/properties-that-can-be-set.htm)