# 105. Streamline with Enigma
Learning goal: Understand how Enigma can be used to work with the QIX Engine API

<div class="graph"></div>

## Meet Enigma
In the previous chapters, we’ve reviewed how the Engine API works at a low level using JSON-RPC messages sent across a WebSocket between a browser and an Engine. Writing and parsing these messages, especially in an asynchronous manner, can be very tedious in JavaScript. Qlik’s Enigma library solves this problem by abstracting the Engine API to a slightly higher level. Enigma is an [open-source library hosted on GitHub](https://github.com/qlik-oss/enigma.js).
</br>
</br>

### A Promise Wrapper
Enigma’s approach to the Engine API is to wrap all of the API methods with _Promises_.  Promises are a way of dealing with asynchronous code. Like their name implies, they execute some function that _promises_ that it will return a value at some point in the future, or error. Promises have useful features such as chaining and error handling that make them much better for asynchronous programming than nested callback functions that developers used to rely on. Promises are now natively supported in JavaScript. [To learn more about Promises and how to use them, we recommend this introduction.](https://developers.google.com/web/fundamentals/getting-started/primers/promises) .

<div id="enigma-create-session" class="graph"></div>

With Enigma, we don’t have to create our own WebSocket connection, write out the individual JSON-RPC messages, or create listeners for the responses. It will handle all of that logic for us, providing an easy Promise interface on top of it. For example, here is an example function for connecting to an Engine:
</br>
</br>

We pass Enigma a  `config` object that will tell it what Engine to connect to. We will cover this configuration later. This creates a `session` for us that we can open to start communicating with the Engine.
</br>
</br>

Like all Enigma asynchronous calls, `session.open()` returns a Promise that will resolve when the session with the Engine has been established. In the example above, once we’ve established the session, the Promise provides us with an object. This object represents our instance of Global class in the session with a handle of -1. 

<div id="session-open" class="graph"></div>

### Handles in Enigma
By using the `session.open()` call above, we were able to connect to an Engine and access an instance of the Global class. Now that we have this instance, we can use it to execute API calls. Recall that we had methods on our Global class like `EngineVersion` and `OpenDoc`. In Enigma, these methods are available directly on objects. These methods will make an API call and return a Promise to us for the result. They are written in camelCase instead of PascalCase, so a call like `EngineVersion` is written as `engineVersion`. For example, I can rewrite the code above to get the Engine version like so:
</br>
</br>

Contrast this code with what we wrote without Enigma in Chapter 103. This is much easier, scalable, and maintainable than writing calls from scratch.

<div id="get-cardinal" class="graph"></div>

For any API call that we make that returns a class instance with a handle, Enigma will give us an interface for that instance with the appropriate API methods. That way, we can get apps, fields, and generic objects and easily make API calls with them as well. Let’s demonstrate using an example from a previous chapter. Let’s connect to an Engine, open a model, get a field, and then get the number of distinct values for that field. In Enigma, we could write this like so:

<div class="graph"></div>

## Configuring Enigma for an Engine
Enigma will set up the WebSocket session for us, so we need to pass it an object that gives it a configuration for our Engine. Enigma is also agnostic to any version of the Engine. Therefore, we also need to pass it an API schema for the version of the Engine that we are using so that it can work properly. These schemas are provided with the Enigma library – we just need to provide the appropriate one.
</br>
</br>

[The configuration is documented on GitHub.](https://github.com/qlik-oss/enigma.js/blob/master/docs/api.md#configuration) Let’s walk through a very simple configuration example.

<div id="engine-config" class="graph"></div>

Assume I want to connect to an Engine on the server `localhost`. The port for the server is `9076`, and I want to open a model called “MyModel”.  The Engine version that I’m connecting to is `12.20.0`. My server uses SSL. With the documentation outlined on GitHub, I would set up the config like so:
</br>
</br>

This config can passed to `enigma.create()` to create a `session` object that can be opened.
</br>
</br>

In the previous chapter, it was mentioned that there are more complex parameters that can be added to a WebSocket URL for connecting to the QIX Engine. Enigma comes with a utility that can take in those parameters via a configuration object and produce the URL for you. [The details on this approach are available in the Sense utilities API documentation.](https://github.com/qlik-oss/enigma.js/blob/master/docs/api.md#sense-utilities-api) 

<div class="graph"></div>

## Handling Invalidation in Enigma
In Chapter 104, we learned about the challenges of staying in sync between our browser and server. We wrote a basic function to monitor change handles from our WebSocket.

<div id="on-change" class="graph"></div>

Enigma makes this process much easier through an event that we can attach callbacks to. In Enigma, every instance has a “changed” event. We can listen and respond to this event like so:

<div id="get-generic-object" class="graph"></div>

This “changed” event corresponds with invalidations. We could therefore use it to keep a Generic Object validated, for example. Let’s say we used Enigma to get a Generic Object by id like so:

<div id="get-layout" class="graph"></div>

We can augment the last part of our code to monitor for change events and make a `getLayout` call whenever the Generic Object is invalidated.

<div class="graph"></div>

## Fin
#### Recap
* Enigma is an open-source library from Qlik that wraps the Engine API in Promises
* Enigma returns objects representing instances in our session. Each instance has appropriate API methods available for it’s class
* Instance invalidation events can be hooked into using the `.on(“changed”)` event listener

#### Resources
* 

#### Troubleshooting Guide
* 
