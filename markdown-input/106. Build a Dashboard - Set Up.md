# 106. Build a Dashboard - Set Up
Learning goal: See how to use QIX and Enigma in practice with an example dashboard

## Project Goal and Overview
There is no better way to learn how to leverage the QIX Engine with APIs than to build an actual dashboard. This chapter will walk us through the very basics of connecting to an engine, opening a model, creating Generic Objects with dynamic data, and rendering that data to the screen. To keep it simple, we will render 2 sets of filters, known as listboxes, for filtering fields in the data. We will also create a chart for analyzing some calculated data in a time-series.

We are going to use an existing model that is hosted on a server provided by Qlik Playground. If you would like to learn more about loading your own data into Qlik models, check out <resource>. 

We’ve loaded data about the United States’ real estate market into our model. We have a table of 60 months’ of average home prices on the market for 15,000 zip codes. The data spans from May 2012 to June 2017 with a total of 928,972 records and was sourced from [Inventory Trends - Realtor.com Economic Research](http://research.realtor.com/data/inventory-trends/). We will use the Associative Model to add a few more tables to make our data easily explorable. We’ve added a table that maps zip codes to city, states, and counties so that we can explore the home price trends at various levels of detail. A table from the Census Bureau that organizes the states into regions is loaded. We’ve also added a table that summarizes the months by Quarter and Year, incase we want to explore the trends at higher levels of aggregation.

Our data model structure looks like so:
![](106.%20Build%20a%20Dashboard%20-%20Set%20Up/Screen%20Shot%202017-07-05%20at%202.36.05%20PM.png)
<clean up this diagram with sketch>

With this model in place, we can explore our data and the associations in many ways. We could look at average listing price by region; the total number of listings by month; the yearly trend of listing prices for states in the Northeast; the list goes on. For our dashboard, we will create the following:
![](106.%20Build%20a%20Dashboard%20-%20Set%20Up/dashboard-sample.png)
<replace with screenshot of completed dashboard>

In this dashboard, we will have filters for the Region and State fields. These filters will be selectable by the user, enabling them to filter values in and out of our data set. They will be implemented with a dynamic property structure called _ListObjects_. The filter will show simple selection states of the field values using the colors green for “Selected” values, white for “Possible” values, and grey for “Excluded” values. We will also have a dynamically calculated chart that will show the trend of average list prices, aggregated by Quarter. The chart will always render based on the current state of the data model. It will leverage a dynamic property structure called the _HyperCube_. Each of these components will have it’s own Generic Object in our model.

We will implement this dashboard with standard HTML5, JavaScript, and CSS. As few frameworks will be used as possible to keep this example as vanilla, allowing you to take the concepts and integrate into the framework of your choosing. If you need a refresher on HTML, JS, and CSS, we recommend the following resources:
<resource list from extensions tutorial>

## Setting Up the Project
While we are keeping this project as simple as possible, we will have a couple of dependencies on other libraries. First, we will use [Enigma](https://github.com/qlik-oss/enigma.js/) to handle our communication with the QIX Engine. Second, we will use an open source charting library called [C3](http://c3js.org/) to produce our data visualization. C3 provides some re-usable charts on top of the D3 library. We will use it so we can focus on the Engine API-specific parts of our code. 

In order to use Enigma, we need to load in an Engine specification. Engine specs for various versions of the Engine are shipped with Enigma’s npm package. JavaScript in the browser does not have any native mechanisms for importing and exporting modules yet. In order to load in these specs and our dependencies in a scalable and maintainable way, we can use a build tool to bundle various files into a single JavaScript file. This will allow us to write JavaScript that imports various modules we need from different files, but still be able to produce a single output that can passed to the browser. For this project, we will use a bundler called [webpack module bundler](https://webpack.github.io/). Webpack is a very robust but complex bundler that can do many things. For this project, we will use a very basic configuration that will resolve dependencies for us that are written in the CommonJs format like so:
`var myModule = require(“./my-module.js”);`

To simplify getting started, we have created a seed project that you can use to set up your dashboard development environment. The seed project is as bare-bones as we can get. It has a _package.json_ file that defines our dependencies:
* `c3` for charting
* `enigma` for the QIX Engine API
* `http-server` for hosting a local development server
* `webpack` for bundling our code

Our _package.json_ file also contains 3 scripts that we can use as part of our development process:
* `bundle` for bundling our source JavaScript into a single output file once
* `watch` for continuously bundling our JavaScript every time a change occurs
* `serve` for launching a local development server on port 3000

Webpack uses the configuration we’ve defined in the _webpack.config.js_ file to use our _srcindex.js_ file as the entry point for the bundling. The final bundle will be saved into the _dist_ directory and named _bundle.js_.

Our general folder structure is simple: all of our final dashboard files go into the _dist_ folder. This folder will hold our HTML, CSS, and bundled JavaScript. Our non-bundled JavaScript will be hosted in the _src_ folder. We will write all of our JS there.

To get started with the seed project, you can download it from GitHub or clone it with `git clone https://github.com/axisgroup/qix-tutorial-seed.git`.

Once you have the project locally, use a terminal to install the dependencies, bundle, and run the project like so:
1. Install dependences with `$ npm install`
2. Create your first bundle with `$ npm run bundle`
3. Serve the project locally with `$ npm run serve`
4. Open a web browser to `localhost:3000` to see the project

This seed doesn’t actually render anything to the screen, so the dashboard will be blank at first.

## Connecting to a Server
All of our JavaScript for our dashboard will go into the _srcindex.js_ file. Let’s edit that file and start with connecting to a server. In order to connect to a server, we need to use the Enigma library, as well as a schema for the Engine we are connecting to. We can load both of these using the CommonJS syntax:

_srcindex.js_
```
var enigma = require("enigma.js");
var qixSchema = require("enigma.js/schemas/12.20.0.json");
```

For our `qixSchema`, we pull the version `12.20.0` schema from the `enigma.js` package. This version corresponds with the Engine that we will be connecting to.

Next, we need to write a config for the Engine to connect to. For this example, we will use an Engine provided by Qlik Playground. It is hosted at <details of server config>. We can translate that into a configuration object for Enigma like so:

_srcindex.js_
```
var enigma = require("enigma.js");
var qixSchema = require("enigma.js/schemas/qix/12.20.0/schema.json");

var config = {
    schema: qixSchema,
    url: "url goes here"
};
```

The config object includes the `qixSchema` we loaded, passed in the `schema` property. For more details on advanced URL configurations for Enigma to connect to an Engine, [check out this document.](https://github.com/qlik-oss/enigma.js/blob/master/docs/api.md#sense-utilities-api) 

Now that we have Enigma and an Engine config defined, we can create a session and connect to the Engine:
```
var enigma = require("enigma.js");
var qixSchema = require("enigma.js/schemas/qix/12.20.0/schema.json");

var config = {
    schema: qixSchema,
    url: "url goes here"
};

var session = enigma.create(config);

session.open().then(function(global) {
    // do something with the Global instance
});
```

The `session.open()` method returns a Promise for an opened session with an Engine. Using the Promise `then` method, we can supply a callback function for this Promise. This callback function receives a Global instance object. We can now use the `global` object to interface with the Engine.

## Opening a Model
Now that we are connected to an Engine, we can open our model. We have a Promise that resolves with an instance of the Global class. In Enigma, all instances of Engine classes have methods that return Promises corresponding with Engine API functionality. As we saw in Chapter 105 and in the [Global class documentation](http://help.qlik.com/en-US/sense-developer/June2017/Subsystems/EngineAPI/Content/Classes/GlobalClass/Global-class.htm), the Global class has a method called `OpenDoc` that can take in an identifier for a model and open it. We can therefore use our Global instance in Enigma to run an `OpenDoc` call that will return a Promise. 

Our model id is “df71b5c0-016b-49c3-bf37-0a4f44eea162”. This was a string autogenerated by a Qlik Sense Server for the model. We can modify our code from above to return a Promise for the `OpenDoc` method that will ultimately return an App instance.

_srcindex.js_
```
session.open().then(function(global) {
    return global.openDoc("df71b5c0-016b-49c3-bf37-0a4f44eea162");
}).then(function(app) {
    console.log("Got an App instance", app);
});
```

As a reminder, in the QIX Engine documentation, the terms “doc” and “app” are used to describe the App class. In this reference guide, we often use the term “model”, which is more applicable to our purposes since we will be using the Associative Model data to build our own dashboard app.

## Fin
#### Recap
* 

#### Resources
* 

#### Troubleshooting Guide
* 


