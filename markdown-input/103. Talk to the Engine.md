# 103. Talk to the Engine
Learning goal: Understand how to communicate with the QIX Engine

<div class="graph"></div>

## Establishing a Session with the Engine
In the previous chapter, we discussed the architecture of the QIX Engine. We learned about the various classes we could interact with, and their methods for performing operations with our models. Now, let’s learn how we can make these calls in practice.
</br>
</br>

In order to run API calls with the QIX Engine, we need to establish a line of communication with it. This line of communication is what we refer to as a _session_. Sessions are established with the Engine via a technology called **WebSockets**.
</br>
</br>

### WebSockets
WebSocket is a protocol that enables an interactive communication session between two entities. They allow bidirectional communication, enabling us to send messages to a service as well as receive messages from a service without polling it. These messages are encoded as strings. 
</br>
</br>

The QIX Engine uses WebSockets for it’s communication. We can send messages to the Engine via a WebSocket to make API calls, and the Engine can send messages back to us through the WebSocket. Each of our WebSocket connections to an Engine correspond with one session. 
</br>
</br>

 WebSockets are implemented in many languages and technologies, including in the browser via JavaScript. For this tutorial, we will be using JavaScript to build a web app with the Engine. Therefore we will show our examples in this chapter using JavaScript, although the same architecture could be implemented in any other language that supports WebSockets.
</br>
</br>

In order to establish a WebSocket connection to an Engine, we need to connect to the proper URL. The QIX Engine uses a specific format for the URL that provides important data for how the session will be established. The simplified format is as follows:

<code>&ltprotocol&gt://&lthost&gt:&ltport&gt/app/&ltroute&gt</code>

* protocol – For secure connections over SSL, ‘wss’ should be used. Otherwise, ‘ws’, should be used
* host – the address where the Engine is hosted
* port – the port that the Engine is listening on
* route – _optional_.  Route to open the WebSocket against; an app GUID can be supplied to reference a specific application that will be opened in the session
</br>
</br>

There are a few other parameters for creating more complex URLs. We will provide more details in the next chapter.
</br>
</br>

Let’s take a look at how we would connect to an example server. Qlik Playground has a server with an Engine that we can connect to as an example. This server is hosted on <code>&lthost&gt</code>, under port <code>&ltport&gt</code>. It requires SSL. We aren’t going to scope to a specific app. Our resulting WebSocket URL will be:
</br>
<code>ws:.....</code>
</br>
</br>

Connecting to this Engine in JavaScript is easy; we just create a new WebSocket connection to the URL:
</br>
<code>var connection = new WebSocket(“url”)</code>
</br>
</br>

We now have a connection with the Engine. We can see this connection and any messages transmitted over it using tools like Google Chrome’s Network panel. <screenshot>
</br>
</br>

We now have a WebSocket with the Engine where we can send and received messages. How do we read and write the messages though? Enter JSON-RPC.
</br>
</br>

### JSONRPC
JSON-RPC is [“a lightweight remote procedure call protocol similar to XML-RPC”](http://json-rpc.org/). In essence, it is a format for our messages. By using this format, the Engine will be able to interpret what we are asking it. In return, we will be able to interpret what the Engine is telling us. Let’s review the standard JSON-RPC specification. 
</br>
</br>

JSON-RPC transmits serialized JSON. This JSON has specific properties defined, depending on the type of message. There are 3 types of messages we may see with JSON-RPC: requests, responses, and notifications.

<div id="json-rpc-request" class="graph"></div>

#### Requests
A request is what you would expect - a method is invoked on a service by sending it a message. The JSON-RPC specification for requests is:
* id – an identifier for the request, which will be used to match to the resulting response
* method – the name of the method to be invoked
* params – an array of parameters to pass along with the method

<div id="json-rpc-response" class="graph"></div>

#### Responses
When we make a request with JSON-RPC, the service must reply with a response. The JSON-RPC specification for responses is:
* id – an identifier that matches the request id
* result – an Object with the result of the request, if it did not error
* error – An Error if an error occurred for the request

<div id="json-rpc-notification" class="graph"></div>

#### Notifications
With JSON-RPC, a message that does not require a response can also be transmitted. These are known as notifications. They use the same format as Requests, except they do not have an ID:

* method – the name of the method to be invoked
* params – an array of parameters to pass along with the method

<div id="browser-qix-websocket" class="graph">![](../../imgs/browser-qix-websocket.png)</div>

With a WebSocket and JSON-RPC, we can communicate with the QIX Engine. We can send it requests in JSON-RPC format, and it will send us responses.

<div class="graph"></div>

## Speaking the Engine’s Language with Handles
We’ve seen how we can send messages with methods to the Engine with the JSON-RPC format. However, how do we tell the Engine where to execute the methods? Recall that the Engine has different classes, which we obtain instances of. For example, I may want to make an API call on a specific field or Generic Object in a model I have open. 
</br>
</br>

In order for the Engine to know what objects to use when executing a method, it uses a distinct identifier for objects called _handles_. A handle is a unique identifier for an object within a session. Handles are numeric integers; the Engine provides them whenever we create or get an instance of a class, with one exception: the Global class. The Global class represents our Engine; there can only be one, so the handle for our Global instance is always `-1`. Let’s use this handle to demonstrate how we make API calls.

<div id="engine-version-request" class="graph"></div>

### Making API Calls with Handles
The Global class has a method called <code>EngineVersion</code> that will return the version of the Engine that we are connected to. We can call this method against our Global instance by supplying the handle as part of a JSON message that follows the JSON-RPC format for requests:
</br>
</br>

In this call, we are indicating that we want to execute the EngineVersion method on the object with handle -1, which is our Global instance. This call has no parameters to be passed, so we just provide an empty array. Finally, we provide the JSON-RPC call an id so that when we get a response from the Engine, we can trace it back to this specific call.

<div id="engine-version-response" class="graph"></div>

The Engine will process this call and send us a response on the WebSocket with the same id. It might look something like this:
</br>
</br>

The Engine version is nested with the “result” property, which is where all results from API calls are stored  in the Engine’s messages to us. 

<div class="graph"></div>

How do we get a handle for entities besides the Engine? Most API methods that create or get objects in the session will return a handle that we can subsequently use to reference that object with API calls. For example, if we want to open a model, we can use the <code>OpenDoc</code> method on the Global class. Once the model is opened, we will get a response from the Engine with a handle for that model. Similarly, we can use a method like <code>GetField</code> on a model, and the Engine will return for us a handle for that field. Let’s see how these calls might look in practice by performing a series of API calls in order to get the number of unique values of a specific field in a model. In order to do this, we need to open the model, then get the field, then call the <code>GetCardinal</code> method on the field. The sequence might look like so:

<div id="get-cardinal" class="graph"></div>

1. Open the model using the Global class. We send the Engine the following message:
</br>
Note that we provide a parameter for the identifier of the model.
The Engine opens the model and returns the handle 1 for it:

2. Now that we have a model open and a handle for it, we can use that handle to get a handle for our field:
</br>
The Engine will return us a handle of 2 for the field:

3. Now that we have a handle for our field, we can get the cardinality of it by sending:
</br>
The Engine returns:

Our field has 3 values in it.

<div id="api-call" class="graph"></div>

### Writing an API call with JavaScript
We’ve abstractly illustrated how API calls are read and written. Let’s review an example implementation with JavaScript. We will use our example for getting the Engine version from our Global class. We’ll do the following steps:
1. Establish a WebSocket connection with the Engine
2. Make an API call to get the Engine version
3. Listen for and identify the response with the Engine version
</br>
</br>

#### Connecting to the Engine
Connecting to the Engine is easy enough; we just set up a WebSocket to the appropriate url:
</br>
</br>

#### Ask for the Engine version
Once the WebSocket has been established, we need to send our API call. The WebSocket opening is an asynchronous event; due to network delays, we need to use a callback function that will be executed when the WebSocket has finished opening. Within this function, we can put our call to send the API call. Note how we convert our JSON to a string before we send it. With JSON-RPC over WebSockets, we need to serialize the JSON.
</br>
</br>

#### Listen for messages from the Engine and find the one that corresponds with the EngineVersion call
In JavaScript, we can provide a callback function that will run every time a message is received. The WebSocket message will be encoded as a string, so we need to parse it into JSON before we can check its id. If it has an id of 1, we can get our Engine version property from it.
</br>
</br>

The end to end code:

<div class="graph"></div>

## Fin
#### Recap
* The Engine uses WebSockets and JSON-RPC to send and receive messages
* We establish a single session with the QIX Engine through a WebSocket
* Within a session, objects we work with are given handles, which identify them for when we make API calls

#### Resources
* [WebSocket - Web APIs | MDN](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)
* [JSON-RPC](http://json-rpc.org/)

#### Troubleshooting Guide
* 
