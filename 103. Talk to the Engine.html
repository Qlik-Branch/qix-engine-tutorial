<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>
    Talk to the Engine
  </title>
  <link href="bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="p3.css" rel="stylesheet"><link href="app.css" rel="stylesheet"></head>

<body>
  <script src="jquery.min.js"></script>
  <script src="bootstrap/dist/js/bootstrap.min.js"></script>

  <!-- <div id="sidebar" class="sidebar">
  <div class="sidebar-label">QIX Tutorial</div>
  <div><a href="javascript:void(0)" class="closebtn">&times;</a></div>
  <hr/>
  <ul class="nav nav-sidebar">
    <li class="chapter-1"><a href="101. What is QIX and Why Should You Care.html"><span class="glyphicon glyphicon-menu-right"></span> 101. What is QIX and why should you care</a>
      <ul class="nav sub-sidebar sublist-0">
        <li><a href="#h2-0">The QIX engine</a></li>
        <li><a href="#h2-1">The associative model: overview</a></li>
        <li><a href="#h2-2">The associative model: breakdown</a></li>
        <li><a href="#h2-3">Leveraging the associative model</a></li>
        <li><a href="#h2-4">Fin</a></li>
      </ul>
    </li>
    <li class="chapter-2"><a href="102. Meet the Engine.html"><span class="glyphicon glyphicon-menu-right"></span> 102. Meet the engine</a>
      <ul class="nav sub-sidebar sublist-1">
        <li><a href="#h2-0">Structure of the associative model</a></li>
        <li><a href="#h2-1">Classes and their methods</a></li>
        <li><a href="#h2-2">Working with generic objects</a></li>
        <li><a href="#h2-3">Fin</a></li>
      </ul>
    </li>
    <li class="chapter-3"><a href="103. Talk to the Engine.html"><span class="glyphicon glyphicon-menu-right"></span> 103. Talk to the Engine</a>
      <ul class="nav sub-sidebar sublist-2">
        <li><a href="#h2-0">Establishing a session with the engine</a></li>
        <li><a href="#h2-1">Speaking the engine's language with handles</a></li>
        <li><a href="#h2-2">Fin</a></li>
      </ul>
    </li>
    <li class="chapter-4"><a href="104. Stay in Sync with the Engine.html"><span class="glyphicon glyphicon-menu-right"></span> 104. Stay in Sync with the Engine</a>
      <ul class="nav sub-sidebar sublist-2">
        <li><a href="#h2-0">Invalidation and the generic object lifecycle</a></li>
        <li><a href="#h2-1">Listening to the engine for invalidation events</a></li>
        <li><a href="#h2-2">Fin</a></li>
      </ul>
    </li>
    <li class="chapter-5"><a href="105. Streamline with Enigma.html"><span class="glyphicon glyphicon-menu-right"></span> 105. Streamline with Enigma</a>
      <ul class="nav sub-sidebar sublist-2">
        <li><a href="#h2-0">Meet enigma</a></li>
        <li><a href="#h2-1">Configuring enigma for an engine</a></li>
        <li><a href="#h2-2">Handling invalidation in enigma</a></li>
        <li><a href="#h2-3">Fin</a></li>
      </ul>
    </li>
    </li>
    <li class="chapter-6"><a href="106. Build a Dashboard - Set Up.html"><span class="glyphicon glyphicon-menu-right"></span> 106. Build a Dashboard - Set Up</a>
      <ul class="nav sub-sidebar sublist-2">
        <li><a href="#h2-0">Project goal and overview</a></li>
        <li><a href="#h2-1">Setting up the project</a></li>
        <li><a href="#h2-2">Connecting to a server</a></li>
        <li><a href="#h2-3">Opening a model</a></li>
        <li><a href="#h2-4">Fin</a></li>
      </ul>
    </li>
    <li class="chapter-7"><a href="107. Creating Filters with ListObjects.html"><span class="glyphicon glyphicon-menu-right"></span> 107. Creating Filters with ListObjects</a>
      <ul class="nav sub-sidebar sublist-2">
        <li><a href="#h2-0">Defining list objects</a></li>
        <li><a href="#h2-1">Setting up data fetching</a></li>
        <li><a href="#h2-2">Getting the list object layouts</a></li>
        <li><a href="#h2-3">Rendering a filter with the layout</a></li>
        <li><a href="#h2-4">Making selections with the filter</a></li>
      </ul>
    </li>
    <li class="chapter-8"><a href="108. Creating Charts with HyperCubes.html"><span class="glyphicon glyphicon-menu-right"></span> 108. Creating Charts with HyperCubes</a>
      <ul class="nav sub-sidebar sublist-2">
        <li><a href="#h2-0">What are hypercubes?</a></li>
        <li><a href="#h2-1">Defining a hypercube</a></li>
        <li><a href="#h2-2">Parsing a hypercube layout</a></li>
        <li><a href="#h2-3">Sorting the hypercube</a></li>
        <li><a href="#h2-4">Visualizing the hypercube</a></li>
        <li><a href="#h2-5">Fin</a></li>
      </ul>
    </li>
  </ul>
</div>

 <div class="hamburger-open">&#9776;</div>  -->

  <div class="main-content">
    <div class="container content">
      <div class="header">
        <h1>103. Talk to the Engine</h1><p>Learning goal: Understand how to communicate with the QIX Engine</p>
          <hr/>
      </div>
      <div id="body-content">
        <div id="section-0"class="section "><div class="row">
              <div class="col-xs-8 col-xs-offset-2 col-sm-8 col-sm-offset-2 col-md-8 col-md-offset-2 col-lg-8 col-lg-offset-2 body-left">
        <h2>Establishing a Session with the Engine</h2><p>In the previous chapter, we discussed the architecture of the QIX Engine. We learned about the various classes we could interact with and their methods for performing operations with our models. Now, let’s learn how we can make these calls in practice.</br></br></p><p>In order to run API calls with the QIX Engine, we need to establish a line of communication with it. This line of communication is what we refer to as a <em>session</em>. Sessions are established with the Engine via a technology called <strong>WebSockets</strong>.</br></br></p><h3>WebSockets</h3><p>WebSocket is a protocol that enables an interactive communication session between two entities. They allow bidirectional communication, enabling us to send messages to a service as well as receive messages from a service without polling it. These messages are encoded as strings.</br></br></p><p>The QIX Engine uses WebSockets for it’s communication. We can send messages to the Engine via a WebSocket to make API calls, and the Engine can send messages back to us through the WebSocket. Each of our WebSocket connections to an Engine correspond with one session.</br></br></p><p>WebSockets are implemented in many languages and technologies, including in the browser via JavaScript. For this tutorial, we will be using JavaScript to build a web app with the Engine. Therefore we will show our examples in this chapter using JavaScript, although the same architecture could be implemented in any other language that supports WebSockets.</br></br></p><p>In order to establish a WebSocket connection to an Engine, we need to connect to the proper URL. The QIX Engine uses a specific format for the URL that provides important data for how the session will be established. The simplified format is as follows:</p><p><code>&ltprotocol&gt://&lthost&gt:&ltport&gt/app/&ltroute&gt</code></p><ul><li><p>protocol – For secure connections over SSL, ‘wss’ should be used. Otherwise, ‘ws’, should be used</p></li><li><p>host – The address where the Engine is hosted</p></li><li><p>port – <em>optional</em>. The port that the Engine is listening on</p></li><li><p>route – <em>optional</em>.  Route to open the WebSocket against; an app GUID can be supplied to reference a specific application that will be opened in the session</br></br></p></li></ul><p>There are a few other parameters for creating more complex URLs. We will provide more details in the next chapter.</br></br></p><p>Let’s take a look at how we would connect to an example server. Qlik Playground has a server with an Engine that we can connect to as an example. This server is hosted on <code>playground-sense.qlik.com</code>, under the default port. It requires SSL. We aren’t going to scope to a specific app. Our resulting WebSocket URL will be:</br><code>wss://playground-sense.qlik.com/app/</code></br></br></p><p>Connecting to this Engine in JavaScript is easy; we just create a new WebSocket connection to the URL:</br><code>var connection = new WebSocket(“wss://playground-sense.qlik.com/app/”)</code></br></br></p></div><div class="col-xs-0 col-sm-0 col-md-0 col-lg-0 body-right"><div class="graph"></div></div></div></div><div id="section-1"class="section chrome-dev-tools"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <p>We now have a connection with the Engine. We can see this connection and any messages transmitted over it using tools like Google Chrome’s Network panel. How do we read and write the messages though? Enter JSON-RPC.</br></br></p><h3>JSONRPC</h3><p>JSON-RPC is <a href="http://json-rpc.org/">“a lightweight remote procedure call protocol similar to XML-RPC”</a>. In essence, it is a format for our messages. By using this format, the Engine will be able to interpret what we are asking it. In return, we will be able to interpret what the Engine is telling us. Let’s review the standard JSON-RPC specification.</br></br></p><p>JSON-RPC transmits serialized JSON. This JSON has specific properties defined, depending on the type of message. There are 3 types of messages we may see with JSON-RPC: requests, responses, and notifications.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="chrome-dev-tools"><img src="./images/chrome-dev-tools.png" alt="" class="img-responsive"></img></div></div></div></div><div id="section-2"class="section json-rpc-request"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <h4>Requests</h4><p>A request is what you would expect - a method is invoked on a service by sending it a message. The JSON-RPC specification for requests is:</p><ul><li><p>id – an identifier for the request, which will be used to match to the resulting response</p></li><li><p>method – the name of the method to be invoked</p></li><li><p>params – an array of parameters to pass along with the method</p></li></ul></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="json-rpc-request"></div></div></div></div><div id="section-3"class="section json-rpc-response"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <h4>Responses</h4><p>When we make a request with JSON-RPC, the service must reply with a response. The JSON-RPC specification for responses is:</p><ul><li><p>id – an identifier that matches the request id</p></li><li><p>result – an Object with the result of the request, if it did not error</p></li><li><p>error – An Error if an error occurred for the request</p></li></ul></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="json-rpc-response"></div></div></div></div><div id="section-4"class="section json-rpc-notification"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <h4>Notifications</h4><p>With JSON-RPC, a message that does not require a response can also be transmitted. These are known as notifications. They use the same format as Requests, except they do not have an ID:</p><ul><li><p>method – the name of the method to be invoked</p></li><li><p>params – an array of parameters to pass along with the method</p></li></ul></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="json-rpc-notification"></div></div></div></div><div id="section-5"class="section browser-qix-websocket"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <p>With a WebSocket and JSON-RPC, we can communicate with the QIX Engine. We can send it requests in JSON-RPC format, and it will send us responses.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="browser-qix-websocket"><img src="./images/browser-qix-websocket.png" alt="" class="img-responsive"></img></div></div></div></div><div id="section-6"class="section "><div class="row">
              <div class="col-xs-8 col-xs-offset-2 col-sm-8 col-sm-offset-2 col-md-8 col-md-offset-2 col-lg-8 col-lg-offset-2 body-left">
        <h2>Speaking the Engine’s Language with Handles</h2><p>We’ve seen how we can send messages with methods to the Engine with the JSON-RPC format. However, how do we tell the Engine where to execute the methods? Recall that the Engine has different classes, which we obtain instances of. For example, I may want to make an API call on a specific field or Generic Object in a model I have open.</br></br></p><p>In order for the Engine to know what objects to use when executing a method, it uses a distinct identifier for objects called <em>handles</em>. A handle is a unique identifier for an object within a session. Handles are numeric integers; the Engine provides them whenever we create or get an instance of a class, with one exception: the Global class. The Global class represents our Engine; there can only be one, so the handle for our Global instance is always -1. Let’s use this handle to demonstrate how we make API calls.</p></div><div class="col-xs-0 col-sm-0 col-md-0 col-lg-0 body-right"><div class="graph"></div></div></div></div><div id="section-7"class="section engine-version-request"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <h3>Making API Calls with Handles</h3><p>The Global class has a method called <code>EngineVersion</code> that will return the version of the Engine that we are connected to. We can call this method against our Global instance by supplying the handle as part of a JSON message that follows the JSON-RPC format for requests:</br></br></p><p>In this call, we are indicating that we want to execute the EngineVersion method on the object with handle -1, which is our Global instance. This call has no parameters to be passed, so we just provide an empty array. Finally, we provide the JSON-RPC call an id so that when we get a response from the Engine, we can trace it back to this specific call.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="engine-version-request"></div></div></div></div><div id="section-8"class="section engine-version-response"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <p>The Engine will process this call and send us a response on the WebSocket with the same id. It might look something like this:</br></br></p><p>The Engine version is nested with the “result” property, which is where all results from API calls are stored  in the Engine’s messages to us.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="engine-version-response"></div></div></div></div><div id="section-9"class="section "><div class="row">
              <div class="col-xs-8 col-xs-offset-2 col-sm-8 col-sm-offset-2 col-md-8 col-md-offset-2 col-lg-8 col-lg-offset-2 body-left">
        <p>How do we get a handle for entities besides the Engine? Most API methods that create or get objects in the session will return a handle that we can subsequently use to reference that object with API calls. For example, if we want to open a model, we can use the <code>OpenDoc</code> method on the Global class. Once the model is opened, we will get a response from the Engine with a handle for that model. Similarly, we can use a method like <code>GetField</code> on a model, and the Engine will return for us a handle for that field. Let’s see how these calls might look in practice by performing a series of API calls in order to get the number of unique values of a specific field in a model. In order to do this, we need to open the model, then get the field, then call the <code>GetCardinal</code> method on the field. The sequence might look like so:</p></div><div class="col-xs-0 col-sm-0 col-md-0 col-lg-0 body-right"><div class="graph"></div></div></div></div><div id="section-10"class="section get-cardinal"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <ol><li><p>Open the model using the Global class. We send the Engine the message seen in <code>Open Doc Request</code> in the code editor to the right</br>Note that we provide a parameter for the identifier of the model.The Engine opens the model and returns the handle 1 for it (seen in <code>Open Doc Response</code>)</br></br></p></li><li><p>Now that we have a model open and a handle for it, we can use that handle to get a handle for our field, as we do in <code>Get Field Request</code></br>The Engine will return us a handle of 2 for the field (<code>Get Field Response</code>)</br></br></p></li><li><p>Now that we have a handle for our field, we can get the cardinality of it by sending GetCardinal as is done in <code>Get Cardinal Request</code></br>The Engine returns <code>Get Cardinal Response</code></br></br></p></li></ol><p>Our field has 3 values in it.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="get-cardinal"></div></div></div></div><div id="section-11"class="section api-call"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <h3>Writing an API call with JavaScript</h3><p>We’ve abstractly illustrated how API calls are read and written. Let’s review an example implementation with JavaScript. We will use our example for getting the Engine version from our Global class. We’ll do the following steps:</p><ol><li><p>Establish a WebSocket connection with the Engine (<code>Connect To Engine</code>)</p></li><li><p>Make an API call to get the Engine version (<code>Request Engine Version</code>)</p></li><li><p>Listen for and identify the response with the Engine version (<code>Engine Version Response</code>)</br></p></li></ol><p>The full solution can be found in <code>End To End</code></br></br></p><h4>Connecting to the Engine</h4><p>Connecting to the Engine is easy enough; we just set up a WebSocket to the appropriate url:</br></br></p><h4>Ask for the Engine version</h4><p>Once the WebSocket has been established, we need to send our API call. The WebSocket opening is an asynchronous event; due to network delays, we need to use a callback function that will be executed when the WebSocket has finished opening. Within this function, we can put our call to send the API call. Note how we convert our JSON to a string before we send it. With JSON-RPC over WebSockets, we need to serialize the JSON.</br></br></p><h4>Listen for messages from the Engine and find the one that corresponds with the EngineVersion call</h4><p>In JavaScript, we can provide a callback function that will run every time a message is received. The WebSocket message will be encoded as a string, so we need to parse it into JSON before we can check its id. If it has an id of 1, we can get our Engine version property from it.</br></br></p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="api-call"></div></div></div></div><div id="section-12"class="section "><div class="row">
              <div class="col-xs-8 col-xs-offset-2 col-sm-8 col-sm-offset-2 col-md-8 col-md-offset-2 col-lg-8 col-lg-offset-2 body-left">
        <h2>Fin</h2><h4>Recap</h4><ul><li><p>The Engine uses WebSockets and JSON-RPC to send and receive messages</p></li><li><p>We establish a single session with the QIX Engine through a WebSocket</p></li><li><p>Within a session, objects we work with are given handles, which identify them for when we make API calls</p></li></ul><h4>Resources</h4><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">WebSocket - Web APIs | MDN</a></p></li><li><p><a href="http://json-rpc.org/">JSON-RPC</a></p></li></ul></div><div class="col-xs-0 col-sm-0 col-md-0 col-lg-0 body-right"><div class="graph"></div></div></div></div>
      </div>
      <hr/>
    </div>
  </div>
<script type="text/javascript" src="p3.bundle.js"></script><script type="text/javascript" src="app.bundle.js"></script></body>

</html>